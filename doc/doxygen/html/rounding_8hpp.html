
<!-- quan_doxygen_header.html -->
<!-- From Sample custom Doxygen header from my_doxygen_header.html  -->-
<!-- Copyright 1998 - 2012 Paul A. Bristow. -->
<!-- Distributed under the Boost Software License, Version 1.0. -->
<!-- (See accompanying file LICENSE_1_0.txt or copy at          -->
<!-- http://www.boost.org/LICENSE_1_0.txt)                      -->
<html> <!-- </html> is in footer. -->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
  <!-- Add your title here ! -->
  <title>Boost.quan Thu Nov 29 2018 13:03:33 Boost.Quan </title>
  <!-- Add your custom stylesheet here ! -->
  <link href="../quan_doxygen.css" rel="stylesheet" type="text/css"/>
  <!-- Note that this overrides any stylesheet specified in doxyfile setting HTML_STYLESHEET="mystylesheet.css" ! -->
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
</head>
<!-- Add draft background here if, for example, not yet accepted or otherwise not finalised. -->
<body style="background-image: url(../../images/draft.png);">
</body>
<!-- You could also flag status by using a color? -->
<!--<body style="background-image: url(../../images/draft.png) ; color : darkblue"> -->
<!-- </body> is in footer. -->
<!-- Add your logo here or -->
<!-- Boost logo here if accepted after review, else some "Proposed for Boost" logo, for example the one below, or "proposed for Boost" ! -->
<table cellpadding="5" width="100%">
  <tbody>
    <tr>
      <td valign="top"><img alt="Proposed for Boost." src="../proposed_for_boost.png" height="80" width="250"/></td>
    </tr>
  </tbody>
</table>
<p>
  <br/>  <!-- Some space below logo, if needed. -->
</p>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_1878a3f4746a95c6aad317458cc7ef80.html">boost</a></li><li class="navelem"><a class="el" href="dir_a7fa3627d3ee0b823f6055a0425355ec.html">quan</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">rounding.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;boost/math/tr1.hpp&gt;</code><br />
<code>#include &lt;boost/math/special_functions/fpclassify.hpp&gt;</code><br />
<code>#include &lt;boost/math/special_functions/sign.hpp&gt;</code><br />
<code>#include &lt;boost/math/distributions/students_t.hpp&gt;</code><br />
<code>#include &lt;boost/math/distributions/normal.hpp&gt;</code><br />
<code>#include &lt;boost/math/distributions/uniform.hpp&gt;</code><br />
<code>#include &lt;boost/math/distributions/triangular.hpp&gt;</code><br />
<code>#include &lt;boost/static_assert.hpp&gt;</code><br />
<code>#include &lt;boost/type_traits/is_floating_point.hpp&gt;</code><br />
<code>#include &lt;boost/concept_check.hpp&gt;</code><br />
<code>#include &lt;boost/quan/impl/xiostream.hpp&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;iomanip&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;locale&gt;</code><br />
</div>
<p><a href="rounding_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aef4282c72dadd0ee53d4778760c25f88"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88">distribution_type</a> { <a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88a224052ac1022b991e847796340c9856a">gaussian</a> = 0, 
<a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88a56013d9ac59a24fb94d9acb932a04b2f">uniform</a> = 1, 
<a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88a305411e526808cc7b14d61687a03fae4">triangular</a> = 2, 
<a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88af35387cab0e820dcf7df1ed4702043e1">undefined</a> = 3
 }</td></tr>
<tr class="separator:aef4282c72dadd0ee53d4778760c25f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad8206ee286a5c7483d0dfcbc8a8e7122"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#ad8206ee286a5c7483d0dfcbc8a8e7122">BOOST_STATIC_ASSERT</a> (std::numeric_limits&lt; double &gt;::is_iec559)</td></tr>
<tr class="memdesc:ad8206ee286a5c7483d0dfcbc8a8e7122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common rounding.  <a href="#ad8206ee286a5c7483d0dfcbc8a8e7122">More...</a><br /></td></tr>
<tr class="separator:ad8206ee286a5c7483d0dfcbc8a8e7122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758ddeff57d9f7c4853a08513284ba78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a758ddeff57d9f7c4853a08513284ba78">BOOST_STATIC_ASSERT</a> (std::numeric_limits&lt; double &gt;::is_specialized)</td></tr>
<tr class="separator:a758ddeff57d9f7c4853a08513284ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421ba8e57c052fd0a922b357e8e1661e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a421ba8e57c052fd0a922b357e8e1661e">operator&lt;&lt;</a> (std::ostream &amp;os, std::pair&lt; double, double &gt; &amp;p)</td></tr>
<tr class="separator:a421ba8e57c052fd0a922b357e8e1661e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fe93fc106f085e31582600bbbf941b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a69fe93fc106f085e31582600bbbf941b">operator&lt;&lt;</a> (std::ostream &amp;os, const std::pair&lt; double, double &gt; &amp;p)</td></tr>
<tr class="separator:a69fe93fc106f085e31582600bbbf941b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0fe2a7102f8190647d988deeab79d3"><td class="memTemplParams" colspan="2">template&lt;typename FPT &gt; </td></tr>
<tr class="memitem:acb0fe2a7102f8190647d988deeab79d3"><td class="memTemplItemLeft" align="right" valign="top">FPT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#acb0fe2a7102f8190647d988deeab79d3">round_sig</a> (FPT v, int n)</td></tr>
<tr class="separator:acb0fe2a7102f8190647d988deeab79d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e1b2ffbf85a1e9f9cbad9a082e80e6"><td class="memTemplParams" colspan="2">template&lt;typename FPT &gt; </td></tr>
<tr class="memitem:a73e1b2ffbf85a1e9f9cbad9a082e80e6"><td class="memTemplItemLeft" align="right" valign="top">FPT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a73e1b2ffbf85a1e9f9cbad9a082e80e6">round_to_n</a> (FPT v, int p)</td></tr>
<tr class="separator:a73e1b2ffbf85a1e9f9cbad9a082e80e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad605368724f41ad94b2a5870be66c1d7"><td class="memTemplParams" colspan="2">template&lt;typename FPT &gt; </td></tr>
<tr class="memitem:ad605368724f41ad94b2a5870be66c1d7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#ad605368724f41ad94b2a5870be66c1d7">round_f</a> (FPT v, int sigdigits)</td></tr>
<tr class="separator:ad605368724f41ad94b2a5870be66c1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e752db4025c76681c4fd2a39ef6b405"><td class="memTemplParams" colspan="2">template&lt;typename FPT &gt; </td></tr>
<tr class="memitem:a0e752db4025c76681c4fd2a39ef6b405"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a0e752db4025c76681c4fd2a39ef6b405">round_ms</a> (FPT v, int m)</td></tr>
<tr class="separator:a0e752db4025c76681c4fd2a39ef6b405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87df983a88adcd4d13fb274ed93cba3a"><td class="memTemplParams" colspan="2">template&lt;typename FPT &gt; </td></tr>
<tr class="memitem:a87df983a88adcd4d13fb274ed93cba3a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a87df983a88adcd4d13fb274ed93cba3a">round_e</a> (FPT d, int sigdigits)</td></tr>
<tr class="separator:a87df983a88adcd4d13fb274ed93cba3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c88c5cb0e8ceedc213935c2f19fa7d3"><td class="memTemplParams" colspan="2">template&lt;typename FPT &gt; </td></tr>
<tr class="memitem:a1c88c5cb0e8ceedc213935c2f19fa7d3"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a1c88c5cb0e8ceedc213935c2f19fa7d3">round_ms</a> (FPT v, signed int m)</td></tr>
<tr class="separator:a1c88c5cb0e8ceedc213935c2f19fa7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11effd445da66dbf084d0b84e1a829b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#ad11effd445da66dbf084d0b84e1a829b">round_nth</a> (double v, unsigned int d)</td></tr>
<tr class="separator:ad11effd445da66dbf084d0b84e1a829b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a6e033c74db75c19017d317353c9bf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#af7a6e033c74db75c19017d317353c9bf">round_1</a> (double v)</td></tr>
<tr class="separator:af7a6e033c74db75c19017d317353c9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababaacd917fd3dae589881370776d559"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#ababaacd917fd3dae589881370776d559">round_2</a> (double v)</td></tr>
<tr class="separator:ababaacd917fd3dae589881370776d559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fcce6b68d8a917eed7002a17722190"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a48fcce6b68d8a917eed7002a17722190">round_3</a> (double v)</td></tr>
<tr class="separator:a48fcce6b68d8a917eed7002a17722190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d40a4d903c57a57ace4cd7aa801662"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a54d40a4d903c57a57ace4cd7aa801662">delta</a> (double epsilon, double <a class="el" href="rounding_8hpp.html#acc8f59a0fa8e166261936c9d2e656117">gamma</a>, <a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88">distribution_type</a> distrib=<a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88a224052ac1022b991e847796340c9856a">gaussian</a>)</td></tr>
<tr class="separator:a54d40a4d903c57a57ace4cd7aa801662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8f59a0fa8e166261936c9d2e656117"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#acc8f59a0fa8e166261936c9d2e656117">gamma</a> (double rounded, double value)</td></tr>
<tr class="separator:acc8f59a0fa8e166261936c9d2e656117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c7ab07f772405ac88c759f037e403b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a63c7ab07f772405ac88c759f037e403b">round_m</a> (double epsilon=0.01, double sigma=0., unsigned int sigma_sigdigits=2U, distribution_type distrib=gaussian)</td></tr>
<tr class="separator:a63c7ab07f772405ac88c759f037e403b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52beabeda129eb8308253c4acd24b18b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a52beabeda129eb8308253c4acd24b18b">round_ue</a> (double v, double sigma, double epsilon=0.01, unsigned int sigdigits=2U)</td></tr>
<tr class="separator:a52beabeda129eb8308253c4acd24b18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8815ff79b3fb65afc1a6b2528a2370"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a1b8815ff79b3fb65afc1a6b2528a2370">conf_interval</a> (double mean, double sigma, double df=1., double alpha=0.05, <a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88">distribution_type</a> distrib=<a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88a224052ac1022b991e847796340c9856a">gaussian</a>)</td></tr>
<tr class="separator:a1b8815ff79b3fb65afc1a6b2528a2370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa67096c98416c7aac7c427436ed40b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a5aa67096c98416c7aac7c427436ed40b">cdf_uni</a> (double z)</td></tr>
<tr class="separator:a5aa67096c98416c7aac7c427436ed40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dc396388d7eadaa74dc4304ac5ef45"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a67dc396388d7eadaa74dc4304ac5ef45">quantile_uni</a> (double alpha)</td></tr>
<tr class="separator:a67dc396388d7eadaa74dc4304ac5ef45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a0c01d75f7990544f05015cec17a14"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a98a0c01d75f7990544f05015cec17a14">cdf_tri</a> (double z)</td></tr>
<tr class="separator:a98a0c01d75f7990544f05015cec17a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37724e4d6b6192c723c3a29b05e4b258"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a37724e4d6b6192c723c3a29b05e4b258">quantile_tri</a> (double alpha)</td></tr>
<tr class="separator:a37724e4d6b6192c723c3a29b05e4b258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61cc9ca92a356b6f0f41b7dedde97ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#ae61cc9ca92a356b6f0f41b7dedde97ba">out_confidence_interval</a> (std::pair&lt; double, double &gt; ci, int m, std::ostream &amp;os=std::cout)</td></tr>
<tr class="separator:ae61cc9ca92a356b6f0f41b7dedde97ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825c7ffc5fb77bab53f8b1ccb3553804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a825c7ffc5fb77bab53f8b1ccb3553804">out_value_limits</a> (double mean, double unc, std::pair&lt; double, double &gt; ci, int m, std::ostream &amp;os=std::cout)</td></tr>
<tr class="separator:a825c7ffc5fb77bab53f8b1ccb3553804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b2c294d95479926fb08f1a0f61c7fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a00b2c294d95479926fb08f1a0f61c7fc">out_value_df_limits</a> (double mean, double unc, int degfree=1, std::ostream &amp;os=std::cout)</td></tr>
<tr class="separator:a00b2c294d95479926fb08f1a0f61c7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a13456ea1c5b9df18650e9407b16f4ca4"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a13456ea1c5b9df18650e9407b16f4ca4">maxdigits10</a> = std::numeric_limits&lt;double&gt;::max_digits10</td></tr>
<tr class="separator:a13456ea1c5b9df18650e9407b16f4ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9245a02b6c61f4b4a7e526d8e9e91166"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rounding_8hpp.html#a9245a02b6c61f4b4a7e526d8e9e91166">scaled</a> = true</td></tr>
<tr class="separator:a9245a02b6c61f4b4a7e526d8e9e91166"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aef4282c72dadd0ee53d4778760c25f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4282c72dadd0ee53d4778760c25f88">&#9670;&nbsp;</a></span>distribution_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88">distribution_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aef4282c72dadd0ee53d4778760c25f88a224052ac1022b991e847796340c9856a"></a>gaussian&#160;</td><td class="fielddoc"><p>Distribution type, encoded into two bits in <code>short int unc_types</code>. </p>
<dl class="section note"><dt>Note</dt><dd><code>gaussian</code> name is chosen rather than <code>normal</code> to avoid name clash from name of bit 11 and bit 12 in <code>enum unc_types</code>.<code>unc_types</code> bit 11 and bit 12 == 0, aka normal. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="aef4282c72dadd0ee53d4778760c25f88a56013d9ac59a24fb94d9acb932a04b2f"></a>uniform&#160;</td><td class="fielddoc"><p><code>unc_types</code> bit 11 == 1, aka rectangular. </p>
</td></tr>
<tr><td class="fieldname"><a id="aef4282c72dadd0ee53d4778760c25f88a305411e526808cc7b14d61687a03fae4"></a>triangular&#160;</td><td class="fielddoc"><p><code>unc_types</code> bit 12 == 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="aef4282c72dadd0ee53d4778760c25f88af35387cab0e820dcf7df1ed4702043e1"></a>undefined&#160;</td><td class="fielddoc"><p><code>unc_types</code> bit 11 and bit 12 == '11' == 3. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01024">1024</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad8206ee286a5c7483d0dfcbc8a8e7122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8206ee286a5c7483d0dfcbc8a8e7122">&#9670;&nbsp;</a></span>BOOST_STATIC_ASSERT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_STATIC_ASSERT </td>
          <td>(</td>
          <td class="paramtype">std::numeric_limits&lt; double &gt;::is_iec559&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common rounding. </p>
<p><a href="http://www.diycalculator.com/popup-m-round.shtml#A3">http://www.diycalculator.com/popup-m-round.shtml#A3</a> all rounding types, including round-to-half and asymmetric and symmetric versions.<br />
 <a href="http://www.chem1.com/acad/webtext/pre/mm3.html">http://www.chem1.com/acad/webtext/pre/mm3.html</a> "The purpose in rounding off is to avoid expressing a value to a greater degree of precision
   than is consistent with the uncertainty in the measurement." "Observed values should be rounded off to the number of digits
   that most accurately conveys the uncertainty in the measurement."</p>
<p>mainpage <b> Proper rounding testbed documentation. </b></p>
<h1><a class="anchor" id="intro_sec"></a>
Introduction to proper rounding.</h1>
<p>This is a testbed for the epsilon-Proper rounding for a few distributions assumed to be appropriate for the data observations.<br />
<br />
Based on:<br />
 Gejza Wimmer, Viktor Witkovsky, Tomas Duby <br />
 Measurement Science and Technolology, 11 (2000) pages 1659-1665. ISSN 0957-0233 S0957-233(00)13838-X.<br />
 Proper rounding of the measurement results under normality assumptions.<br />
<br />
 Gejza Wimmer, Viktor Witkovsky, Proper rounding of the measurement result under the assumption of uniform distribution, <br />
 Measurement Science Review, Vol 2, section 1, (2002), pages 1 - 7.<br />
<br />
 Gejza Wimmer, Viktor Witkovsky, Proper rounding of the measurement result under the assumption of triangular distribution, <br />
 Measurement Science Review, Vol 2, section 1, (2002), pages 21 to 31.<br />
</p>

</div>
</div>
<a id="a758ddeff57d9f7c4853a08513284ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758ddeff57d9f7c4853a08513284ba78">&#9670;&nbsp;</a></span>BOOST_STATIC_ASSERT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_STATIC_ASSERT </td>
          <td>(</td>
          <td class="paramtype">std::numeric_limits&lt; double &gt;::is_specialized&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98a0c01d75f7990544f05015cec17a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a0c01d75f7990544f05015cec17a14">&#9670;&nbsp;</a></span>cdf_tri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cdf_tri </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cumulative distribution function CDF of triangular distribution. Gejza Wimmer, Viktor Witkovsky, Tomas Duby, Proper rounding of the measurement result under the assumption of triangular distribution, Measurement Science Review, Vol 2, section 1, (2002), page 24, equation 7.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDF of triangular distribution.</dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01414">1414</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a5aa67096c98416c7aac7c427436ed40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa67096c98416c7aac7c427436ed40b">&#9670;&nbsp;</a></span>cdf_uni()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cdf_uni </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cumulative distribution Function of uniform distribution Un(-sqrt_3, + sqrt_3), with an expectation of mean zero and variance unity. Gejza Wimmer &amp; Victor Witkovsky, Measurement Science Review, volume 2 section 1 2002, page 3, equation 5. </p><dl class="section return"><dt>Returns</dt><dd>Cumulative distribution Function of uniform distribution.</dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01387">1387</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a1b8815ff79b3fb65afc1a6b2528a2370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8815ff79b3fb65afc1a6b2528a2370">&#9670;&nbsp;</a></span>conf_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;double, double&gt; conf_interval </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>df</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.05</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88">distribution_type</a>&#160;</td>
          <td class="paramname"><em>distrib</em> = <code><a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88a224052ac1022b991e847796340c9856a">gaussian</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate confidence interval for chosen alpha confidence level and chosen distribution type.</p>
<p>Uses confidence interval equations from:<br />
 Gejza Wimmer, Viktor Witkovsky, Tomas Duby Measurement Science and Technolology, 11 (2000) 1659-1665. ISSN 0957-0233 S0957-233(00)13838-X. Proper rounding of the measurement result under the assumption of gaussian distribution,<br />
 Confidence interval equation 6, p 1660.</p>
<p>Gejza Wimmer, Viktor Witkovsky, Tomas Duby<br />
 Measurement Science and Technolology, 11 (2000) 1659-1665. ISSN 0957-0233 S0957-233(00)13838-X.<br />
 Proper rounding of the measurement result under the assumption of triangular distribution,<br />
 Measurement Science Review, Vol 2, section 1, (2002), pages 21 to 31.<br />
 Confidence interval Equation 12, page 25.<br />
 Gejza Wimmer, Viktor Witkovsky,<br />
 Proper rounding of the measurement result under the assumption of uniform distribution,<br />
 Measurement Science Review, Vol 2, section 1, (2002), pages 1 - 7.<br />
 Confidence interval, page 5, equation 13.<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>Interval estimate for mean mu. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard uncertainty sigma from variance sigma. </td></tr>
    <tr><td class="paramname">df</td><td>Degrees of freedom (usually number of observations -1). </td></tr>
    <tr><td class="paramname">alpha</td><td>Confidence (0. &lt; unc &lt; 1.), typically 0.05 for 95% confidence. alpha/2 = 0.025 quantile = -1.96, and 1 - alpha/2 is 1.96 for normal distribution, so typically confidence interval is roughly twice unc either side (+ or - ) of mean. </td></tr>
    <tr><td class="paramname">distrib</td><td>Distribution type, Gaussian(default), uniform, triangular, laplace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Confidence interval upper and lower limits as a <code>std::pair</code> of <code>double</code>.</dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01293">1293</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a54d40a4d903c57a57ace4cd7aa801662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d40a4d903c57a57ace4cd7aa801662">&#9670;&nbsp;</a></span>delta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double delta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88">distribution_type</a>&#160;</td>
          <td class="paramname"><em>distrib</em> = <code><a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88a224052ac1022b991e847796340c9856a">gaussian</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate Wimmer delta function using equation 24, p 1664.</p>
<p>Gejza Wimmer, Viktor Witkovsky, Tomas Duby<br />
Measurement Science and Technology, 11 (2000) pages 1659-1665. ISSN 0957-0233 S0957-233(00)13838-X.<br />
Proper rounding of the measurement results under normality assumptions.<br />
Gejza Wimmer, Viktor Witkovsky, Proper rounding of the measurement result under the assumption of uniform distribution,<br />
Measurement Science Review, Vol 2, section 1, (2002), pages 1 - 7.<br />
Gejza Wimmer, Viktor Witkovsky, Proper rounding of the measurement result under the assumtpion of triangular distribution,<br />
Measurement Science Review, Vol 2, section 1, (2002), pages 21 to 31.<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epsilon</td><td>Proper-rounding increase of confidence interval because of rounding, must be positive and 'small'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>epsilon is usually 0.05 or 95%, values in range 0.2 to 0.01 make good sense, 0.2 (80%) risks a fair bit of loss from rounding, 0.01 (1%) causes almost no loss. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gamma</td><td>Ratio rounded / unrounded (gamma is assumed &lt;= 1). </td></tr>
    <tr><td class="paramname">distrib</td><td>Distribution type, normal or gaussian(default), uniform, triangular, or laplace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of Wimmer delta function using equation 24, p 1664, for normal distribution, and similar for triangular and uniform. Returns -1 if epsilon is too 'tight' so must be increased for delta to be calculated. Throwing an exception might be better here&gt;</dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01034">1034</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="acc8f59a0fa8e166261936c9d2e656117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8f59a0fa8e166261936c9d2e656117">&#9670;&nbsp;</a></span>gamma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rounded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate Wimmer gamma rounded/unrounded function p 1664.</p>
<p>Compute a measure of information loss from rounding <code>value</code> to <code>rounded</code>. </p><dl class="section see"><dt>See also</dt><dd>Measurement Science and Technolology, 11 (2000) 1659-1665. ISSN 0957-0233 S0957-233(00)13838-X. Gejza Wimmer, Viktor Witkovsky, Tomas Duby, Proper rounding of the measurement results under normality assumptions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rounded</td><td>Value (as <code>double</code>) after rounding. </td></tr>
    <tr><td class="paramname">value</td><td>Value (as <code>double</code>) before rounding. Assumes <code>rounded</code> &lt; <code>unrounded</code> value`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ratio rounded / value, a measure of loss of information caused by rounding.</dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01122">1122</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a421ba8e57c052fd0a922b357e8e1661e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421ba8e57c052fd0a922b357e8e1661e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; double, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output a pair of <code>double</code>s, using &lt; &gt; angle brackets and comma separator, using current stream's precision..</p>
<p>Explicit specialization for <code>std::pair</code> for <code>double</code>s.<br />
For example: &lt;97.8725, 157.798&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pair of doubles. </td></tr>
    <tr><td class="paramname">os</td><td>std::ostream for string output.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l00148">148</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a69fe93fc106f085e31582600bbbf941b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fe93fc106f085e31582600bbbf941b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; double, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output a pair of <code>double</code>s, using &lt; &gt; angle brackets and comma separator, using current stream's precision..</p>
<p>Explicit specialization for <b><code>const</code></b> <code>std::pair</code> for <code>double</code>s.<br />
For example: &lt;97.8725, 157.798&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pair of <code>double</code> to be output to stream os. </td></tr>
    <tr><td class="paramname">os</td><td><code>std::ostream</code> for string output.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l00160">160</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="ae61cc9ca92a356b6f0f41b7dedde97ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61cc9ca92a356b6f0f41b7dedde97ba">&#9670;&nbsp;</a></span>out_confidence_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void out_confidence_interval </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; double, double &gt;&#160;</td>
          <td class="paramname"><em>ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output to os, confidence interval enclosed in brackets and separated by comma. The precision is controlled by the rounding order <code>m</code> used for the mean but with one extra decimal digit of precision, so rounding to m-1 th place. For example: &lt;99.5, 156.5&gt; rounding to -1 position (where the mean was rounded with m == 0, using the units digit to round the tens digit to "128.")</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ci</td><td>Confidence interval or limits. </td></tr>
    <tr><td class="paramname">m</td><td>Signed position for rounding. </td></tr>
    <tr><td class="paramname">os</td><td><code>std::ostream</code> for output.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01458">1458</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a00b2c294d95479926fb08f1a0f61c7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b2c294d95479926fb08f1a0f61c7fc">&#9670;&nbsp;</a></span>out_value_df_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void out_value_df_limits </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>unc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degfree</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output mean, uncertainty and confidence interval. For example:</p><pre class="fragment">128. +/- 15 \&lt;99.5, 156.5\&gt;  </pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>Mean or central estimate of value. </td></tr>
    <tr><td class="paramname">unc</td><td>Uncertainty estimate as standard deviation. </td></tr>
    <tr><td class="paramname">degfree</td><td>Number of degrees of freedom. </td></tr>
    <tr><td class="paramname">os</td><td><code>std::ostream</code> for output.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01500">1500</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a825c7ffc5fb77bab53f8b1ccb3553804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825c7ffc5fb77bab53f8b1ccb3553804">&#9670;&nbsp;</a></span>out_value_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void out_value_limits </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>unc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; double, double &gt;&#160;</td>
          <td class="paramname"><em>ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output mean, uncertainty and confidence interval. For example:</p><pre class="fragment">128. +/- 15 &lt;99.5, 156.5&gt;  </pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>Mean or central estimate of value. </td></tr>
    <tr><td class="paramname">unc</td><td>Uncertainty estimate as standard deviation. </td></tr>
    <tr><td class="paramname">ci</td><td>Confidence interval as an interval. </td></tr>
    <tr><td class="paramname">m</td><td>Rounding position. </td></tr>
    <tr><td class="paramname">os</td><td><code>std::ostream</code> for output.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01477">1477</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a37724e4d6b6192c723c3a29b05e4b258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37724e4d6b6192c723c3a29b05e4b258">&#9670;&nbsp;</a></span>quantile_tri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double quantile_tri </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Quantile or Inverse of cumulative distribution function CDF of triangular distribution. Gejza Wimmer, Viktor Witkovsky, Tomas Duby, Proper rounding of the measurement result under the assumption of triangular distribution, Measurement Science Review, Vol 2, section 1, (2002), page 24, equation 8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Confidence level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Quantile or Inverse of cumulative distribution function CDF.</dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01438">1438</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a67dc396388d7eadaa74dc4304ac5ef45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dc396388d7eadaa74dc4304ac5ef45">&#9670;&nbsp;</a></span>quantile_uni()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double quantile_uni </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Quantile of uniform distribution Uniform(-sqrt_3, + sqrt_3), expectation or mean zero and variance unity. Wimmer &amp; Witkovsky, Measurement Science Review, volume 2 section 1 2002, page 3, eq 6. </p><dl class="section return"><dt>Returns</dt><dd>Quantile of uniform distribution.</dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01403">1403</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="af7a6e033c74db75c19017d317353c9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a6e033c74db75c19017d317353c9bf">&#9670;&nbsp;</a></span>round_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double round_1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>round value v to 1 digit after decimal point, using 1st digit to round. </p>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01012">1012</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="ababaacd917fd3dae589881370776d559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababaacd917fd3dae589881370776d559">&#9670;&nbsp;</a></span>round_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double round_2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>round value v to 2 digit2 after decimal point, using 2nd digit to round. </p>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01016">1016</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a48fcce6b68d8a917eed7002a17722190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fcce6b68d8a917eed7002a17722190">&#9670;&nbsp;</a></span>round_3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double round_3 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>round value v to 3 digit2 after decimal point, using 3rd digit to round. </p>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01020">1020</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a87df983a88adcd4d13fb274ed93cba3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87df983a88adcd4d13fb274ed93cba3a">&#9670;&nbsp;</a></span>round_e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FPT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string round_e </td>
          <td>(</td>
          <td class="paramtype">FPT&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sigdigits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Show only <code>sigdigits</code> digits, in minimal scientific or 'e' format only, rounded asymmetric (round-half-up, arithmetic rounding).<br />
 Round asymmetric avoids values like 0.15, which cannot be stored exactly in binary IEEE 754 floating-point format and are stored internally as 1.499999999999, being rounded unexpectedly to 0.1 rather than 0.2. For example: format -1.2345e12 or 1.2345e-123.</p>
<dl class="section note"><dt>Note</dt><dd>the difference in meaning of precision from default, fixed and scientific, for example: <code>d = 19.99;</code> <br />
 <code>cerr &lt;&lt; setprecision(2) &lt;&lt; d &lt;&lt; endl; // 20 // rounded</code><br />
 <code>cerr &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; d &lt;&lt; endl; // 20.0 - rounded up.</code><br />
 <code>cerr &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; d &lt;&lt; endl; // 19.99 - 2 digits after decimal point.</code><br />
 <code>cerr &lt;&lt; scientific &lt;&lt; setprecision(2) &lt;&lt; d &lt;&lt; endl; // 2.00e+001 - 2 digits after decimal point</code></dd></dl>
<p>Also remove all redundant exponent characters and digits, See <a href="http://en.wikipedia.org/wiki/Rounding">http://en.wikipedia.org/wiki/Rounding</a> .</p>
<dl class="section note"><dt>Note</dt><dd>The normal rounding provided by C and C++ is chosen to avoid loss of accuracy and bias in any further <b>binary</b> calculations. The rounded decimal digit <b>strings</b> returned are provided solely for <b>human</b> viewing and should NOT be used for input to other calculations when one or two extra noisy digits are needed to avoid loss of information by rounding. If it is necessary to provide a decimal digit string for input, it should use <code>std::numeric_limits&lt;FPT&gt;::max_digits10</code> in C++0x, or <code>2</code> + std::numeric_limits&lt;FPT&gt;::digits * 3010/10000 if the platform implementation of C++ Standard IOstream library does not yet provide this. For 64-bit double, <code>max_digits10</code> is 17, so write <code>cout.precision(17)</code>. This will avoid any bias or loss of accuracy in statistical calculations caused by rounding.</dd>
<dd>
The C++ Standard IOstream library does not specify any guarantee about accuracy of input from a decimal digits string to internal floating-point format like <code>double</code>.<br />
The compiler will always convert a literal floating-point to the <b>nearest</b> <b>representable</b> <b>value</b>, but the C++ Standard IOstream library is <b>not</b> <b>required</b> do this. In particular, MSVC 8.0 (2007) and 10.0 (2010) do not quite always achieve this for <code>defaultfloat</code> format - about 1/3 third of significand values in the range 0.0001 to 0.003894 are not input to the nearest representable double, but are 1-bit different.</dd></dl>
<p>It is impracticable to test all floating-point values in a useful time, so random values were tested.</p>
<p>For details see:</p>
<p><a href="http://lab.msdn.microsoft.com/productfeedback/viewfeedback.aspx?feedbackid=7bf2f26d-171f-41fe-be05-4169a54eef9e">http://lab.msdn.microsoft.com/productfeedback/viewfeedback.aspx?feedbackid=7bf2f26d-171f-41fe-be05-4169a54eef9e</a></p>
<p>aka <a href="http://tinyurl.com/mpk72">http://tinyurl.com/mpk72</a></p>
<p>This is very significant if you wish to 'round-trip' (outputting a value and reading it back in again) for example with lexical_cast or using Boost.Serialization. A test like</p>
<p>assert(value_output == value_reinput)</p>
<p>will fail <em>very</em> intermittently.</p>
<p>So if this is important to you, use the scientific (exponential) format with precision max_digits10 (17 for double) where random tests have not revealed any differences.</p>
<p>Logic is using C++ std printf-style rounding to start with a decimal digit string with rounded value of digits10, only the guaranteed correct digits to get the best estimate of the digit to be used for the final rounding. Hopefully, any imprecision caused by inexact presentation is (binary) rounded away.</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.exploringbinary.com/">http://www.exploringbinary.com/</a> for much more detail of defects in other libraries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only lowercase letter e is used, and positive exponents are not preceeded by + sign, and leading zeros are omitted.<br />
This is done to make the display as compact as possible.<br />
If a fixed width is needed, the user program must provide any necessary padding, using the size (length) of the string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>value to be converted to decimal digit string. </td></tr>
    <tr><td class="paramname">sigdigits</td><td>number of significant digits to show in string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string containing value rounded and converted to <code>sigdigits</code> decimal digits in exponential format.</dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l00247">247</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="ad605368724f41ad94b2a5870be66c1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad605368724f41ad94b2a5870be66c1d7">&#9670;&nbsp;</a></span>round_f()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FPT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string round_f </td>
          <td>(</td>
          <td class="paramtype">FPT&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sigdigits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Round floating-point value <code>v</code> (fixed, not-exponential) to <code>sigdigits</code> significant digits. This is variously called 'common rounding', 'round_5_up'.</p>
<p>Gejza Wimmer, Viktor Witkovsky, Tomas Duby<br />
 Measurement Science and Technology, 11 (2000) 1659-1665. ISSN 0957-0233 S0957-233(00)13838-X<br />
 Proper rounding of the measurement results under normality assumptions.<br />
 Uncertainty of measurement &ndash; Part 3: Guide to the expression of uncertainty in measurement (GUM:1995)<br />
 ISO Guide 98 (1995) and updated version 2008.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Value to be converted to a decimal digit string, rounded to sigdigits significant digits. </td></tr>
    <tr><td class="paramname">sigdigits</td><td>Number of significant digits after rounding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::string</code> containing decimal digit string, properly rounded.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>All these functions are templated on floating-point type and are not intended to be called (and thus instantiated) for integral (or other) types. This is because the value will not be output in scientific format, assumed by the code. A check is_floating_point == true is provide that will fail in debug mode. (A compile time check would be better).</dd>
<dd>
C++0X provides <code>std::numeric_limits&lt;double&gt;::max_digits10</code>; which is maximum possibly significant decimal digits, but only <code>digit10</code> are guaranteed to be significant, so limit <code>sigdigits</code> to <code>digits10</code> (15 for IEEE 64-bit double). (But may be better to allow max_digits10?)</dd></dl>
<ul>
<li></li>
</ul>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l00746">746</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a63c7ab07f772405ac88c759f037e403b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c7ab07f772405ac88c759f037e403b">&#9670;&nbsp;</a></span>round_m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int round_m </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sigma_sigdigits</em> = <code>2U</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88">distribution_type</a>&#160;</td>
          <td class="paramname"><em>distrib</em> = <code><a class="el" href="rounding_8hpp.html#aef4282c72dadd0ee53d4778760c25f88a224052ac1022b991e847796340c9856a">gaussian</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the Wimmer rounding digit m using delta and gamma functions p 1661, equation 12.</p>
<p>Measurement Science and Technology, 11 (2000) 1659-1665. ISSN 0957-0233 S0957-233(00)13838-X. Gejza Wimmer, Viktor Witkovsky, Tomas Duby<br />
Proper rounding of the measurement results under normality assumptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epsilon</td><td>Rounding loss (as fraction) accepted (default is 0.01 or 1%). </td></tr>
    <tr><td class="paramname">sigma</td><td>Uncertainty as standard deviation. </td></tr>
    <tr><td class="paramname">sigma_sigdigits</td><td>Number of significant decimal digits for uncertainty to be rounded (range 1 to 4, default = 2), depending on degrees of freedom.<br />
If degrees_of_freedom &lt;= 2, then 1, else if degrees_of_freedom &gt; 1000, then 3 else default = 2. </td></tr>
    <tr><td class="paramname">distrib</td><td>Type of distribution (default gaussian, or triangular or uniform).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m Signed position of the digit to be used for rounding, <code>m == 0</code> means use the units digit for rounding the tens digit.</dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01160">1160</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a0e752db4025c76681c4fd2a39ef6b405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e752db4025c76681c4fd2a39ef6b405">&#9670;&nbsp;</a></span>round_ms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FPT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string round_ms </td>
          <td>(</td>
          <td class="paramtype">FPT&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c88c5cb0e8ceedc213935c2f19fa7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c88c5cb0e8ceedc213935c2f19fa7d3">&#9670;&nbsp;</a></span>round_ms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FPT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string round_ms </td>
          <td>(</td>
          <td class="paramtype">FPT&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Round floating-point v (not-exponential) to order m (where m is the index of the rounder digit). This is variously called 'common rounding', 'round_5_up'.</p>
<p>Gejza Wimmer, Viktor Witkovsky, Tomas Duby<br />
 Measurement Science and Technology, 11 (2000) 1659-1665. ISSN 0957-0233 S0957-233(00)13838-X<br />
 Proper rounding of the measurement results under normality assumptions.<br />
 Uncertainty of measurement &ndash; Part 3: Guide to the expression of uncertainty in measurement (GUM:1995)<br />
 ISO Guide 98 (1995) and updated version 2008.<br />
<br />
 </p><dl class="section note"><dt>Note</dt><dd><code>m</code> is the index of the rounder digit, that is the just insignificant digit used to decide if the m+1th digit is to be rounded up or left as is. So <code>m == 0</code> means that the rounder digit is the units digits, used to round the tens digit, <code>m == +1</code> the rounder is the tens digit, and the rounded digit is the hundreds digit <code>m == -1</code> rounder is the tenths digit (0.1), rounding the hundredths digit (0.01).</dd></dl>
<p>(Other authors specify the nth digit to be significant, where n = m + 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Value to convert to decimal digit string after rounding. </td></tr>
    <tr><td class="paramname">m</td><td>Signed digit position to round. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::string</code> decimal digit string of rounded value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>that the most significant sign bit of NaN is recognized by using function signbit, <br />
 'sign' of NaNs cannot reliably and portably be tested using "x &lt; 0" because all comparisons using NaN are false - by definition. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l00484">484</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="ad11effd445da66dbf084d0b84e1a829b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11effd445da66dbf084d0b84e1a829b">&#9670;&nbsp;</a></span>round_nth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double round_nth </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>round value v to d digits after decimal point, using d+1 digit to round. </p>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01006">1006</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="acb0fe2a7102f8190647d988deeab79d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0fe2a7102f8190647d988deeab79d3">&#9670;&nbsp;</a></span>round_sig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FPT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FPT round_sig </td>
          <td>(</td>
          <td class="paramtype">FPT&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns v rounded to n significant decimal digits.<br />
<a href="http://www.jason.mock.ws/wordpress/2007/02/22/round-a-float-to-of-significant-digits,">http://www.jason.mock.ws/wordpress/2007/02/22/round-a-float-to-of-significant-digits,</a> David A. Pimentel</p>
<p>These use log10 and pow and so are vulnerable to binary rounding errors, as the value may not be exactly representable for the type specified. Should give the same value as printf precision. (int)(x &lt; 0 ? x - 0.5 : x + 0.5)) So do we need to do something different for negative doubles? The difference between symmetric and asymmetric rounding?</p>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l00190">190</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a73e1b2ffbf85a1e9f9cbad9a082e80e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e1b2ffbf85a1e9f9cbad9a082e80e6">&#9670;&nbsp;</a></span>round_to_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FPT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FPT round_to_n </td>
          <td>(</td>
          <td class="paramtype">FPT&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Round value v to p decimal digits <b>after</b> the decimal point. <a href="http://www.jason.mock.ws/wordpress/2007/02/22/round-a-float-to-of-significant-digits">http://www.jason.mock.ws/wordpress/2007/02/22/round-a-float-to-of-significant-digits</a> </p><dl class="section note"><dt>Note</dt><dd>These use log10 and pow and so are vulnerable to binary rounding errors, as the value v may not be exactly representable for the type specified. Should give the same value as printf precision.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Value to round. </td></tr>
    <tr><td class="paramname">p</td><td>Number of decimal digits <b>after</b> the decimal point.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l00229">229</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a52beabeda129eb8308253c4acd24b18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52beabeda129eb8308253c4acd24b18b">&#9670;&nbsp;</a></span>round_ue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string round_ue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sigdigits</em> = <code>2U</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Properly round value to a decimal digit <code>std::string</code>.</p>
<p>Measurement Science and Technolology, 11 (2000) 1659-1665. ISSN 0957-0233 S0957-233(00)13838-X.<br />
 Gejza Wimmer, Viktor Witkovsky, Tomas Duby, Proper rounding of the measurement results under normality assumptions. p 1661, equation 12.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Central value, often estimate of mean. </td></tr>
    <tr><td class="paramname">sigma</td><td>Uncertainty of value, usually standard deviation. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Fraction of loss of accuracy from rounding permitted (default 1%). </td></tr>
    <tr><td class="paramname">sigdigits</td><td>Number of digits that are significant (default 2).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Decimal digit <code>std::string</code> containing rounded value.</dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l01273">1273</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a13456ea1c5b9df18650e9407b16f4ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13456ea1c5b9df18650e9407b16f4ca4">&#9670;&nbsp;</a></span>maxdigits10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int maxdigits10 = std::numeric_limits&lt;double&gt;::max_digits10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l00143">143</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
<a id="a9245a02b6c61f4b4a7e526d8e9e91166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9245a02b6c61f4b4a7e526d8e9e91166">&#9670;&nbsp;</a></span>scaled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool scaled = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="rounding_8hpp_source.html#l00743">743</a> of file <a class="el" href="rounding_8hpp_source.html">rounding.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- custom Doxygen footer quan_doxygen_footer.html  -->-
<!-- Copyright 2012 Paul A. Bristow -->
<!-- Distributed under the Boost Software License, Version 1.0. -->
<!-- (See accompanying file LICENSE_1_0.txt or copy at          -->
<!-- http://www.boost.org/LICENSE_1_0.txt)                      -->
<hr size="1"/>
<table width="100%">
<tbody>
  <tr>
   <address style="text-align: left;">
     <p>Use, modification and distribution are subject to the Boost Software License, Version 1.0.<br/>
     (See accompanying file LICENSE_1_0.txt or copy at&nbsp;
     <a href="http://www.boost.org/LICENSE_1_0.txt"> http://www.boost.org/LICENSE_1_0.txt </a>)</p>
      <!-- Change copyright to YOUR name (and affiliation, if any) below:  -->
     <p>Copyright  2018 Paul A. Bristow</p>
      <!-- 2018 becomes the current year, for example 2010, so claims copyright for a range of years, 2009 - 2010. -->
     <p>Doxygen Documentation generated by&nbsp;<a href="http://www.doxygen.org/index.html"> <img src="doxygen.png" alt="doxygen logo" align="middle" border="0"/> 1.8.14</a>, Revised at Thu Nov 29 2018 13:03:33</p>
  </address>
  </tr>
</tbody>
</table>
  <!-- You can also add a footer logo, taking care that the location of the footer.png is correct. -->
  <!-- <img src="../images/my_footer.png" alt="Boost Doxygen documentation footer.png" -->
  </body> <!-- <body> is in doxygen_header.html -->
</html><!-- <html>  is in doxygen_header.html -->
